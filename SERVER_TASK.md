# Задача: Разработка Серверной части для Remote Storage (FastAPI)

Необходимо разработать серверную часть (Backend) для системы удаленного хранения файлов.
**Клиентская часть (Агент) уже написана и работает.** Сервер должен строго соответствовать существующему протоколу Агента.

## 1. Стек технологий
*   **Язык:** Python 3.10+
*   **Фреймворк:** FastAPI (для WebSocket и REST API).
*   **БД:** SQLite (для простоты) или PostgreSQL. Использовать SQLAlchemy (async) или Tortoise ORM.
*   **Асинхронность:** `asyncio` обязателен.

## 2. Архитектура
Сервер выполняет роль посредника (Command & Control) и временного буфера.
У сервера есть два "лица":
1.  **Agent Interface (WebSocket + Internal API):** Для подключения агентов, отправки им команд и обмена бинарными данными файлов.
2.  **User Interface (REST API):** Для конечного пользователя (человека), который хочет загрузить файл в свое "облако" или скачать его.

## 3. База данных
Необходимо реализовать минимум две таблицы:
1.  **Agents:**
    *   `id` (String): Уникальный ID агента.
    *   `token` (String): Секретный токен для авторизации.
    *   `status` (Boolean): Online/Offline.
    *   `host_info` (JSON): Инфо о свободном месте (обновляется при подключении).
2.  **Files:**
    *   `id` (String): UUID файла.
    *   `filename` (String): Имя файла.
    *   `agent_id` (FK): На каком агенте лежит.
    *   `size` (Int): Размер.
    *   `uploaded_at`: Дата.

## 4. Логика работы (Самое важное!)

### А. Подключение Агента
1.  Агент подключается к `ws://YOUR_SERVER/ws`.
2.  Сразу шлет JSON: `{"action": "auth", "token": "...", "agent_id": "..."}`.
3.  Сервер проверяет токен в БД. Если ОК — держит соединение открытым и сохраняет объект WebSocket в памяти (словарь `active_connections`).

### Б. Сценарий "Пользователь загружает файл" (User Upload)
1.  **User** делает `POST /api/user/upload` (multipart/form-data).
2.  **Server**:
    *   Принимает поток данных и сохраняет во **временный файл** на сервере (папка `temp/`).
    *   Создает запись в БД `Files`.
    *   Генерирует уникальный `request_id`.
    *   Генерирует временную ссылку для скачивания: `http://YOUR_SERVER/api/agent/download_temp/{file_id}`.
    *   Отправляет Агенту через WebSocket команду `upload`:
        ```json
        {
          "action": "upload",
          "request_id": "req_123",
          "file_info": { "id": "...", "name": "...", "size": ... },
          "download_url": "http://YOUR_SERVER/api/agent/download_temp/{file_id}"
        }
        ```
    *   **ЖДЕТ** (await), пока Агент не пришлет ответ в WebSocket с тем же `request_id`.
3.  **Agent**: Скачивает файл по ссылке `download_url`, сохраняет у себя, шлет ответ `success`.
4.  **Server**: Получив `success`, удаляет временный файл и возвращает Пользователю `200 OK`.

### В. Сценарий "Пользователь скачивает файл" (User Download)
1.  **User** делает `GET /api/user/files/{file_id}`.
2.  **Server**:
    *   Находит, какому агенту принадлежит файл.
    *   Генерирует ссылку для приема данных: `http://YOUR_SERVER/api/agent/upload_temp/{file_id}`.
    *   Отправляет Агенту через WebSocket команду `download`:
        ```json
        {
          "action": "download",
          "request_id": "req_124",
          "file_id": "...",
          "upload_url": "http://YOUR_SERVER/api/agent/upload_temp/{file_id}"
        }
        ```
    *   **ЖДЕТ** ответа от Агента.
3.  **Agent**: Читает файл у себя, делает `POST` на `upload_url`.
4.  **Server (Endpoint `upload_temp`)**: Принимает поток от агента, сохраняет во временный файл.
5.  **Agent**: Шлет в WebSocket `{"status": "success", ...}`.
6.  **Server**: Получив сигнал успеха, начинает отдавать (Stream) временный файл Пользователю в ответе на исходный GET запрос. После отдачи — удаляет временный файл.

## 5. Технические требования к реализации
1.  **Менеджер соединений:** Реализовать класс `ConnectionManager`, который хранит активные WebSocket соединения и позволяет отправлять сообщения конкретному `agent_id`.
2.  **Ожидание ответа (Async Wait):** Так как WebSocket асинхронный, HTTP-запрос пользователя должен "заснуть" в ожидании ответа от агента. Используй `asyncio.Future` или `Event`. Создай словарь `pending_requests = { "req_id": Future }`. Когда в WS приходит ответ, находи `Future` по ID и разблокируй его.
3.  **Временные файлы:** Обязательно удалять временные файлы после завершения транзакции (даже в случае ошибки), чтобы не забить диск сервера.

## 6. Пример JSON-сообщений (Строго соблюдать!)
Смотри файл `API.md` (или код клиента `client/network.py`).
*   Команды сервера: `upload`, `download`, `delete`, `info`.
*   Ответы агента: `{"action": "response", "request_id": "...", "status": "success/error"}`.

**Задача:** Написать полный код сервера (main.py, models.py, routers и т.д.), который реализует эту логику.
